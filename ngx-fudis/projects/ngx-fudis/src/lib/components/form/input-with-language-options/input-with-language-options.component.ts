import {
  AfterViewInit,
  Component,
  DestroyRef,
  EventEmitter,
  Input,
  OnChanges,
  OnInit,
  Output,
  effect,
  inject,
} from '@angular/core';
import { FormControl, FormGroup } from '@angular/forms';
import {
  FudisInputWithLanguageOptionsFormGroup,
  FudisSelectOption,
  FudisDropdownLanguageOption,
  FudisInputSize,
} from '../../../types/forms';
import { FudisIdService } from '../../../services/id/id.service';
import { FudisTranslationService } from '../../../services/translation/translation.service';
import {
  // getMaxLengthFromValidator,
  hasRequiredValidator,
} from '../../../utilities/form/getValidators';
import { FudisComponentChanges } from '../../../types/miscellaneous';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { Subject } from 'rxjs';
import { FudisDOMUtilitiesService } from '../../../services/dom/dom-utilities.service';
import { TooltipApiDirective } from '../../../directives/tooltip/tooltip-api.directive';

// TODO: Write Storybook documentation and add missing internal documentation for the functions (add public/private)
@Component({
  selector: 'fudis-input-with-language-options',
  templateUrl: './input-with-language-options.component.html',
  styleUrls: ['./input-with-language-options.component.scss'],
  providers: [FudisDOMUtilitiesService],
})
export class InputWithLanguageOptionsComponent
  extends TooltipApiDirective
  implements OnInit, OnChanges, AfterViewInit
{
  constructor(
    private _translationService: FudisTranslationService,
    private _idService: FudisIdService,
    protected _DOMUtilitiesService: FudisDOMUtilitiesService,
  ) {
    super();
    effect(() => {
      const translations = _translationService.getTranslations()();

      this._languageLabel = translations.INPUT_WITH_LANGUAGE_OPTIONS.LANGUAGE;
      this._missingLanguage = translations.INPUT_WITH_LANGUAGE_OPTIONS.MISSING;
      if (this.options) {
        this._updatedOptions = this.updateDropdownList();
      }
    });

    this._updateValueAndValidityTrigger.pipe(takeUntilDestroyed()).subscribe(() => {
      if (this.formGroup) {
        // this._required = hasRequiredValidator(this.control);
        // this._maxLength = getMaxLengthFromValidator(this.control);
      }
    });
  }

  /**
   * FormGroup including controls.
   */
  @Input({ required: true }) formGroup: FormGroup<FudisInputWithLanguageOptionsFormGroup<object>>;

  /**
   * Option list for language selection Fudis Dropdown. To pair control with corresponding dropdown option Dropdown option "value" must equal to control's name. E.g. "{value: 'english', label: 'EN'}" pairs with "english: New FormControl('')"
   */
  @Input({ required: true }) options: FudisDropdownLanguageOption[];

  /**
   * Available sizes for the input - defaults to large.
   */
  @Input() size: FudisInputSize = 'lg';

  /**
   * Form element to display. Defaults to text-input
   */
  @Input() variant: 'text-input' | 'text-area' = 'text-input';

  /**
   * Label for the input.
   */
  @Input({ required: true }) label: string;

  /**
   * Provide additional information for screen reader users by extending text content of the label. Used in e. g. input with language options for providing info about currently selected language.
   */
  @Input() ariaLabel: string;

  /**
   * Input id. If not provided, generated by Id Service
   */
  @Input() id: string;

  /**
   * If component is a child of Form component, Form's Error Summary is visible, this component's control has errors and when this component is loaded for the first time, it will by default call Error Summary to reload itself again and mark control as touched. This is because if component is lazy loaded to the DOM after the initial reload errors call was made, errors of this component might not appear on the list. To disable this feature, set this to false.
   */
  @Input() errorSummaryReloadOnInit: boolean = true;

  // TODO: Disabling should be done straight from the form control. But because form control sets HTML disabled="true" and not only aria-disabled="true", this will be prevent user to focus on input even if it 'disabled'. As long this Angular 'feature' exists, we should 'manually' provide disabling through input as well.

  /**
   * Option for disabling the input.
   */
  @Input() disabled: boolean = false;

  /**
   * Help text, aligned underneath the input.
   */
  @Input() helpText: string | undefined;

  /**
   * Set input's visual style and attributes as invalid. Does not override if control.invalid is true.
   */
  @Input() invalidState: boolean = false;

  /**
   * Set browser focus to the input on the first load.
   */
  @Input() initialFocus: boolean = false;

  /**
   * Disable guidance for this component instance. No help text or errors will be visible.
   */
  @Input() disableGuidance: boolean;

  /**
   * To listen for input's blur event.
   */
  @Output() handleBlur: EventEmitter<FocusEvent> = new EventEmitter<FocusEvent>();

  /**
   * To listen for input's key up event.
   */
  @Output() handleKeyUp: EventEmitter<KeyboardEvent> = new EventEmitter<KeyboardEvent>();

  /**
   * Fudis translation key for required text
   */
  protected _requiredText: string;

  /**
   * Set requiredText based on this boolean value
   */
  protected _required: boolean = false;

  /**
   * Max length for HTML attribute and for character indicator in guidance
   */
  protected _maxLength: number | null = null;

  /**
   * Min length for HTML attribute and for character indicator in guidance
   */
  protected _minLength: number | null = null;

  protected _destroyRef = inject(DestroyRef);

  /**
   * Trigger update when control validator is changed
   */
  protected _updateValueAndValidityTrigger = new Subject<void>();

  /**
   * To trigger Error Summary reload when this component's children Validator Error Messages are initialised. This is used in cases when this component is lazy loaded to DOM after initial Error Summary reload was called before children Validator Error Messages existed. E. g. if component is inside lazy loaded expandable.
   */
  protected _reloadErrorSummary = false;

  /**
   * Handle blur event
   */
  public onBlur(event: FocusEvent): void {
    this.handleBlur.emit(event);
  }

  /**
   * Update value and validity of control
   */
  protected _applyControlUpdateCheck(): void {
    const original = this.formGroup.updateValueAndValidity;

    this.formGroup.updateValueAndValidity = () => {
      original.apply(this.formGroup);
      this._updateValueAndValidityTrigger.next();
    };
  }

  /**
   * Control for language option dropdown
   */
  protected _dropdownControl: FormControl<FudisSelectOption<object>>;

  /**
   * Property to check control values for required language options
   */
  protected _requiredControls: {
    [key: string]: { value?: string | null; required: boolean | undefined };
  } = {};

  /**
   * Updated options list after changes
   */
  protected _updatedOptions: FudisSelectOption<object>[] = [];

  /**
   * Fudis translation
   */
  protected _missingLanguage: string;

  /**
   * Fudis translation
   */
  protected _languageLabel: string;

  /**
   * If component is loaded for the first time
   */
  protected _firstLoad: boolean = true;

  /**
   * Language option dropdown value
   */
  private _dropdownValue: FudisSelectOption<object>;

  /**
   * For attribute for dropdown value
   */
  private _for: string = '';

  /**
   * At least one language input is required
   */
  private _atLeastOneRequired: boolean = false;

  /**
   * Property to check that control is not empty
   */
  private _nonEmptyControls: string[] = [];

  handleLanguageSelect(value: FudisSelectOption<object> | null): void {
    if (value) {
      this._dropdownValue = value;
      this._for = `${this.id}_${value.value}`;
    }
  }

  handleInputBlur(event: Event, controlKey: string): void {
    this._updatedOptions = this.updateDropdownList();
    this.formGroup.markAllAsTouched();

    this.isControlRequired((event.target as HTMLInputElement).value, controlKey);
  }

  updateDropdownList(): FudisSelectOption<object>[] {
    const newOptions: FudisSelectOption<object>[] = [];

    this.options.forEach((option) => {
      if (
        this.formGroup.controls[option.controlName].invalid ||
        !this.formGroup.controls[option.controlName].value
      ) {
        const updatedOption = {
          value: option.controlName,
          label: `${option.label} (${this._missingLanguage})`,
        };

        newOptions.push(updatedOption);

        if (option.controlName === this._dropdownControl?.value.value) {
          this._dropdownControl.patchValue(updatedOption);
        }
      } else {
        const patchOption = { value: option.controlName, label: option.label };

        if (option.controlName === this._dropdownControl?.value.value) {
          this._dropdownControl.patchValue(patchOption);
        }
        newOptions.push(patchOption);
      }
    });

    return newOptions;
  }

  /**
   * OnInit check to forward necessary "required" attributes to all generated inputs.
   */
  initialRequiredCheck(): void {
    this._requiredControls = {};

    // TODO: change this._atLeastOneRequired to be fetched with getValidators

    if (this.formGroup.errors?.['atLeastOneRequired']) {
      this._atLeastOneRequired = true;

      Object.keys(this.formGroup.controls).forEach((control) => {
        this._requiredControls = {
          ...this._requiredControls,
          [control]: {
            value: this.formGroup.controls[control].value,
            required: this._atLeastOneRequired,
          },
        };
      });
    } else {
      Object.keys(this.formGroup.controls).forEach((control) => {
        const isRequired = hasRequiredValidator(this.formGroup.controls[control]);

        this._requiredControls = {
          ...this._requiredControls,
          [control]: {
            value: this.formGroup.controls[control].value,
            required: isRequired ? true : undefined,
          },
        };
      });
    }
  }

  // TODO: as Required input property has been removed, an alternative logic needs to be implemented

  /**
   * Check onBlur if required is needed to be shown
   */
  isControlRequired(value: string, controlKey: string): void {
    // If all controls are invalid run initialRequiredCheck()
    if (this.formGroup.errors?.['atLeastOneRequired']) {
      this.initialRequiredCheck();
    } else if (this._atLeastOneRequired && controlKey) {
      // Check how many controls are empty
      this._requiredControls[controlKey].value = value;

      this._nonEmptyControls = Object.keys(this._requiredControls).filter((control) => {
        return (
          this._requiredControls[control].value !== '' &&
          this._requiredControls[control].value !== null
        );
      });

      // If only one control is not empty, include required with that
      if (this._nonEmptyControls.length === 1) {
        this._requiredControls = {};
        Object.keys(this.formGroup.controls).forEach((control) => {
          const isRequired = hasRequiredValidator(this.formGroup.controls[control]);

          this._requiredControls = {
            ...this._requiredControls,
            [control]: {
              value: this.formGroup.controls[control].value,
              required: this._nonEmptyControls.includes(control) || isRequired ? true : undefined,
            },
          };
        });
      }

      // If two or more controls have a value, remove visible required text unless control has FudisValidators.required() or Validators.required
      if (this._atLeastOneRequired && this._nonEmptyControls.length > 1) {
        this._requiredControls = {};
        Object.keys(this.formGroup.controls).forEach((control) => {
          const isRequired = hasRequiredValidator(this.formGroup.controls[control]);

          this._requiredControls = {
            ...this._requiredControls,
            [control]: {
              value: this.formGroup.controls[control].value,
              required: isRequired,
            },
          };
        });
      }
    }
  }

  ngOnInit(): void {
    /**
     * Add given id to Id Service or generate unique id
     */
    if (this.id) {
      this._idService.addNewId('input-with-language-options', this.id);
    } else {
      this.id = this._idService.getNewId('input-with-language-options');
    }
  }

  ngOnChanges(changes: FudisComponentChanges<InputWithLanguageOptionsComponent>): void {
    if (changes.formGroup?.currentValue !== changes.formGroup?.previousValue) {
      this._updatedOptions = this.updateDropdownList();

      this._dropdownControl = new FormControl(this._updatedOptions[0]);
      this._for = `${this.id}_${this.options[0].controlName}`;

      this.initialRequiredCheck();
    }
  }

  ngAfterViewInit(): void {
    if (this._firstLoad) {
      this._firstLoad = false;
    }
    this._DOMUtilitiesService.setLabelHeight(true);
  }
}
